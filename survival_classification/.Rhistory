#### Post-process ----
if(verbose) cat(section,"Post-process \n")
# Graphical results ----
if(verbose) cat(task,"Export graphical results \n")
Export_images()
#### Clean up ----
if(verbose) cat(section,"Ending \n")
if(verbose) cat(task,"Save \n")
Path <- paste(results_path,"/Param_curves.RData",sep="")
save(data_pretreated, final_data, file = Path)
if(verbose) cat(task,"Clean up \n")
invisible(file.remove(Clustering_path))
invisible(file.remove(Proba_path))
rm(list=ls())
################################################################################
################ Survival curve classification
####### Elise Comte and Paul-Marie Grollemund
####### 2021-04-29 : first implementation
####### 2023-05-10 : major update
####### 2024-04-02 : make the script reusable
################################################################################
#### Clean up ----
rm(list=ls())
# Required initial packages ----
suppressPackageStartupMessages(library(rjson))
suppressPackageStartupMessages(library(tictoc))
## Get shell options (manual) ----
args <- commandArgs(trailingOnly=TRUE)
setwd("~/Documents/MCF/Recherche/UMRF/Elegans/Survival_classification/git_survival_clustering/survival_classification/")
args <- c("./options/options.json","./options/specific_options_test.json")
if(length(args)>1){
# general options
json_file <- args[1]
json_data <- fromJSON(file=json_file)
for(i in 1:length(json_data)){
assign(names(json_data)[i], json_data[[i]])
}
# specific options
json_file_bis <- args[2]
json_data_bis <- fromJSON(file=json_file_bis)
for(i in 1:length(json_data_bis)){
assign(names(json_data_bis)[i], json_data_bis[[i]])
}
}else{
stop("You need to specify the path to the options files. \nCheck the folder 'options'.")
}
setwd(wd)
get(load("src/error_distribution.RData"))
################################################################################
################ Survival curve classification
####### Elise Comte and Paul-Marie Grollemund
####### 2021-04-29 : first implementation
####### 2023-05-10 : major update
####### 2024-04-02 : make the script reusable
################################################################################
#### Clean up ----
rm(list=ls())
# Required initial packages ----
suppressPackageStartupMessages(library(rjson))
suppressPackageStartupMessages(library(tictoc))
## Get shell options (manual) ----
args <- commandArgs(trailingOnly=TRUE)
# setwd("~/Documents/MCF/Recherche/UMRF/Elegans/Survival_classification/git_survival_clustering/survival_classification/")
# args <- c("./options/options.json","./options/specific_options_test.json")
if(length(args)>1){
# general options
json_file <- args[1]
json_data <- fromJSON(file=json_file)
for(i in 1:length(json_data)){
assign(names(json_data)[i], json_data[[i]])
}
# specific options
json_file_bis <- args[2]
json_data_bis <- fromJSON(file=json_file_bis)
for(i in 1:length(json_data_bis)){
assign(names(json_data_bis)[i], json_data_bis[[i]])
}
}else{
stop("You need to specify the path to the options files. \nCheck the folder 'options'.")
}
################################################################################
################ Survival curve classification
####### Elise Comte and Paul-Marie Grollemund
####### 2021-04-29 : first implementation
####### 2023-05-10 : major update
####### 2024-04-02 : make the script reusable
################################################################################
#### Clean up ----
rm(list=ls())
# Required initial packages ----
suppressPackageStartupMessages(library(rjson))
suppressPackageStartupMessages(library(tictoc))
## Get shell options (manual) ----
args <- commandArgs(trailingOnly=TRUE)
setwd("~/Documents/MCF/Recherche/UMRF/Elegans/Survival_classification/git_survival_clustering/survival_classification/")
args <- c("./options/options.json","./options/specific_options_test.json")
if(length(args)>1){
# general options
json_file <- args[1]
json_data <- fromJSON(file=json_file)
for(i in 1:length(json_data)){
assign(names(json_data)[i], json_data[[i]])
}
# specific options
json_file_bis <- args[2]
json_data_bis <- fromJSON(file=json_file_bis)
for(i in 1:length(json_data_bis)){
assign(names(json_data_bis)[i], json_data_bis[[i]])
}
}else{
stop("You need to specify the path to the options files. \nCheck the folder 'options'.")
}
setwd(wd)
#### Initialization ----
source("scripts/initialization.R")
# Launch ----
if(verbose){
cat(part,"\n",
"Survival curve clustering \n",
" version ",version," \n",
part,"\n",sep="")
}
tic("Running time")
#### Initialization ----
if(verbose) cat(section," Initialization \n",sep="")
# Required packages ----
if(verbose) cat(task," Import packages \n",sep="")
suppressPackageStartupMessages(library(cobs))
suppressPackageStartupMessages(library(fda,quietly = TRUE))
suppressPackageStartupMessages(library(funFEM))
suppressPackageStartupMessages(library(ggplot2))
suppressPackageStartupMessages(library(ggpubr))
suppressPackageStartupMessages(library(ggthemes))
suppressPackageStartupMessages(library(mclust,quietly=TRUE))
suppressPackageStartupMessages(library(MLmetrics))
suppressPackageStartupMessages(library(nlme))
suppressPackageStartupMessages(library(purrr))
suppressPackageStartupMessages(library(survival))
suppressPackageStartupMessages(library(truncnorm))
suppressPackageStartupMessages(library(utils))
# Create output dir ----
if(verbose) cat(task," Create output directory \n",sep="")
if(!dir.exists(folder_path))
dir.create(path = folder_path)
results_path <- paste0(folder_path,"/res")
if(!dir.exists(results_path))
dir.create(path = results_path)
img_path <- paste0(folder_path,"/img")
if(!dir.exists(img_path))
dir.create(path = img_path)
# Required functions ----
if(verbose) cat(task," Import functions \n",sep="")
source(script_functions)
source(choice_functions)
#### Data ----
if(verbose) cat(section," Database \n",sep="")
# Import data ----
if(verbose) cat(task," Import data \n",sep="")
if(verbose) cat(subtask,"Read from database \n")
data <- import_data(data_file, sheet)
control <- import_data(control_file, control_sheets)
# Pretreat ----
if(verbose) cat(task,"Pretreat \n")
if(verbose) cat(subtask,"Time \n")
time_max <- compute_time_max(data)
Time <- seq(0,time_max,length.out = simulated_data.time_number)
if(verbose) cat(subtask,"Survival curves \n")
data_pretreated <- pretreatment(data)
data -> Data
if (deparse(substitute(Data)) == "control") { # control data
P_surv_curves <-data_pretreated[data_pretreated$cond %in% control_sheets,]
} else { # data related to treatments
# Data simulation
simulated_data <- change_data(Data)
n_Wells <- 0
for (i in 1:length(simulated_data)) {
for (j in 1:length(unique(simulated_data[[i]]$num_duplic))) {
data_tmp <-
simulated_data[[i]][which(simulated_data[[i]]$num_duplic == unique(simulated_data[[i]]$num_duplic)[j]), ]
n_Wells <- n_Wells + length(unique(data_tmp$rep.intra))
}
}
# Initialisation
Approx <- list() ; length(Approx) <- simulated_data.time_number*n_Wells
name <- list() ; length(name) <- n_Wells
Wells <- list() ; length(Wells) <- n_Wells*simulated_data.time_number
Cond <- list() ; length(Cond) <- n_Wells*simulated_data.time_number
MSE_cobs <- data.frame(MSE = rep(NA, n_Wells), Curves = rep(NA, n_Wells))
Treat <- list() ; length(Treat) <- n_Wells*simulated_data.time_number
# Survival expansion
iter <- 1
pb <- txtProgressBar(min = 0, max = n_Wells * simulated_data.time_number, style = 3)
counter <- 0
for (j in 1:length(simulated_data)) {
for (l in 1:length(unique(simulated_data[[j]]$num_duplic))) {
data_tmp <-
simulated_data[[j]][which(simulated_data[[j]]$num_duplic ==
unique(simulated_data[[j]]$num_duplic)[l]),]
N <- MSpline(data_tmp)
for (i in 1:length(unique(data_tmp$rep.intra))) {
name[iter] <-
paste(names(simulated_data)[[j]], "rep", i, "duplic",
unique(simulated_data[[j]]$num_duplic)[l], sep = "_")
MSE_cobs$MSE[iter] <- N[simulated_data.time_number + 1, i]
MSE_cobs$Curves[iter] <- name[[iter]]
for (k in 1:simulated_data.time_number) {
Approx[((iter - 1) * simulated_data.time_number) + k] <- N[k, i]
counter <- counter + 1
setTxtProgressBar(pb, counter)
}
iter <- iter + 1
}
}
}
close(pb)
# Compute each well
for (i in 1:n_Wells) {
for (j in 1:simulated_data.time_number) {
Wells[((i - 1) * simulated_data.time_number) + j] <- name[[i]]
}
}
# Compute the experimental condition name
iter <- 1
for (i in 1:length(simulated_data)) {
i_Treat <- NA
for (k in 1:length(treat_group)) {
for (l in 1:length(treat_group[[k]])) {
if (treat_group[[k]][l] == names(simulated_data)[[i]]) {
i_Treat <- k
}
}
}
for (l in 1:length(unique(simulated_data[[i]]$num_duplic))) {
data_tmp <-
simulated_data[[i]][which(simulated_data[[i]]$num_duplic == unique(simulated_data[[i]]$num_duplic)[l]),]
for (k in 1:length(unique(data_tmp$rep.intra))) {
for (j in 1:simulated_data.time_number) {
Cond[iter] <- names(simulated_data)[[i]]
if(!is.na(i_Treat)){
Treat[iter] <- treat_names[i_Treat]
}else{
Treat[iter] <- NA
}
iter <- iter + 1
}
}
}
}
# Compute the survival curves : P_surv_curves
P_surv_curves <- data.frame(
time = rep(Time, n_Wells),
surv = as.numeric(as.matrix(Approx)),
cond = unlist(Cond),
Wells = unlist(Wells),
Treat = unlist(Treat)
)
P_surv_curves <- P_surv_curves[!is.na(P_surv_curves$Treat),]
}
# Data simulation
simulated_data <- change_data(Data)
n_Wells <- 0
# Initialize
n <- n_simulated_data
simulated_data <- list() ; length(simulated_data) <- length(Data)
i
# For each experimental condition
for (i in 1:length(Data)) {
real_data <- real_dataframe(Data[[i]])
for (j in unique(real_data$Wells)) {
data_by_Wells <- real_data[which(real_data$Wells == j),]
data_by_Wells$n_nematode[data_by_Wells$n_nematode<0] <- 0
if (names(Data)[[i]] %in% control_sheets) { # PMG 2024-04-02
simulation <- simul_data(data_by_Wells,n) # PMG 2023-05-19 : j'ai mis n Ã  la place de 0
} else {
simulation <- simul_data(data_by_Wells,n)
}
for (k in unique(simulation$num_duplic)) {
data_tmp <- simulation[which(simulation$num_duplic == k),]
# PMG (2023-05-19) : rajoute quelque chose au cas ou le nbre de nematode soit
#        constant ce qui pose un pb dans le calcul
if( all(data_tmp$n_nematode == data_tmp$n_nematode[1]) ){
data_tmp$n_nematode[length(data_tmp$n_nematode)] <-
max(data_tmp$n_nematode[length(data_tmp$n_nematode)] - 2,0)
data_tmp$n_nematode[1] <- data_tmp$n_nematode[1]+1
}
reformat <- reformat_dataframe(data_tmp)
if (k == unique(simulation$num_duplic)[1]) {
reformat_simulation <- reformat
} else {
reformat_simulation <- rbind(reformat_simulation, reformat)
}
}
if (j == unique(real_data$Wells)[1]) {
newdata <- reformat_simulation
} else {
newdata <- rbind(newdata, reformat_simulation)
}
simulated_data[[i]] <- newdata
}
}
i
real_data <- real_dataframe(Data[[i]])
real_dataframe(Data[[i]]
real_dataframe(Data[[i]])
unique(real_data$Wells)
j <- unique(real_data$Wells)[1]
j
data_by_Wells <- real_data[which(real_data$Wells == j),]
data_by_Wells
data_by_Wells$n_nematode[data_by_Wells$n_nematode<0] <- 0
names(Data)[[i]] %in% control_sheets
if (names(Data)[[i]] %in% control_sheets) { # PMG 2024-04-02
simulation <- simul_data(data_by_Wells,n) # PMG 2023-05-19 : j'ai mis n Ã  la place de 0
} else {
simulation <- simul_data(data_by_Wells,n)
}
data_by_Wells
n
simul_data(data_by_Wells,n) # PMG 2023-05-19 : j'ai mis n Ã  la place de 0
data <- data_by_Wells
n
load(error_sd_file)
get(load(error_sd_file))
head(get(load(error_sd_file)))
load(error_distribution_file)
eps <- 0.2
time_size <- nrow(data)
Simul <-
data.frame(
time = rep(data$time, n),
n_nematode = rep(NA, n*time_size),
status = rep(data$status[1], n*time_size),
strain = rep(data$strain[1], n*time_size),
Wells = rep("duplic", each = n*time_size),
rep.intra = rep(data$rep.intra[1], n*time_size),
rep.inter = rep(data$rep.inter[1], n*time_size),
num_duplic = rep(1:n, each = time_size)
)
Simul <- rbind(Simul, data)
Simul$num_duplic <- factor(Simul$num_duplic)
i <- 1
# First day
n_nematode <- data$n_nematode[1]
new_n_nematode <- sim_n_nematode(n_nematode,smooth_error_distribution)
sim_n_nematode
n_nematode
smooth_error_distribution
error_sd_file
n_nematode
error <- 0
n_nematode >= 35
n_nematode < 35 &  n_nematode >= 10
error <-
sample(smooth_error_distribution$error[smooth_error_distribution$moyenne == n_nematode],
1,
prob = smooth_error_distribution$freq[smooth_error_distribution$moyenne == n_nematode])
smooth_error_distribution
smooth_error_distribution$error
smooth_error_distribution$moyenne == n_nematode
smooth_error_distribution
head(smooth_error_distribution)
sim_n_nematode(n_nematode,smooth_error_distribution)
# Nematode count simulation
sim_n_nematode <- function(n_nematode,smooth_error_distribution){
error <- 0
if(n_nematode >= 35){
error <-
sample(smooth_error_distribution$error[smooth_error_distribution$mean == 35],
1,
prob = smooth_error_distribution$freq[smooth_error_distribution$mean == 35])
}
if(n_nematode < 35 &  n_nematode >= 10){
error <-
sample(smooth_error_distribution$error[smooth_error_distribution$mean == n_nematode],
1,
prob = smooth_error_distribution$freq[smooth_error_distribution$mean == n_nematode])
}
if(n_nematode < 10 & n_nematode > 0){
error <- sample(c(-1,0,1),1,prob=c(0.2,0.6,0.2))
}
if(n_nematode == 0){
error <- sample(c(0,1),1,prob=c(0.95,0.5))
}
new_n_nematode <- n_nematode + error
if(new_n_nematode<0) new_n_nematode <- 0
return(new_n_nematode)
}
sim_n_nematode(n_nematode,smooth_error_distribution)
################################################################################
################ Survival curve classification
####### Elise Comte and Paul-Marie Grollemund
####### 2021-04-29 : first implementation
####### 2023-05-10 : major update
####### 2024-04-02 : make the script reusable
################################################################################
#### Clean up ----
rm(list=ls())
# Required initial packages ----
suppressPackageStartupMessages(library(rjson))
suppressPackageStartupMessages(library(tictoc))
## Get shell options (manual) ----
args <- commandArgs(trailingOnly=TRUE)
setwd("~/Documents/MCF/Recherche/UMRF/Elegans/Survival_classification/git_survival_clustering/survival_classification/")
args <- c("./options/options.json","./options/specific_options_test.json")
if(length(args)>1){
# general options
json_file <- args[1]
json_data <- fromJSON(file=json_file)
for(i in 1:length(json_data)){
assign(names(json_data)[i], json_data[[i]])
}
# specific options
json_file_bis <- args[2]
json_data_bis <- fromJSON(file=json_file_bis)
for(i in 1:length(json_data_bis)){
assign(names(json_data_bis)[i], json_data_bis[[i]])
}
}else{
stop("You need to specify the path to the options files. \nCheck the folder 'options'.")
}
setwd(wd)
#### Initialization ----
source("scripts/initialization.R")
# Launch ----
if(verbose){
cat(part,"\n",
"Survival curve clustering \n",
" version ",version," \n",
part,"\n",sep="")
}
tic("Running time")
#### Initialization ----
if(verbose) cat(section," Initialization \n",sep="")
# Required packages ----
if(verbose) cat(task," Import packages \n",sep="")
suppressPackageStartupMessages(library(cobs))
suppressPackageStartupMessages(library(fda,quietly = TRUE))
suppressPackageStartupMessages(library(funFEM))
suppressPackageStartupMessages(library(ggplot2))
suppressPackageStartupMessages(library(ggpubr))
suppressPackageStartupMessages(library(ggthemes))
suppressPackageStartupMessages(library(mclust,quietly=TRUE))
suppressPackageStartupMessages(library(MLmetrics))
suppressPackageStartupMessages(library(nlme))
suppressPackageStartupMessages(library(purrr))
suppressPackageStartupMessages(library(survival))
suppressPackageStartupMessages(library(truncnorm))
suppressPackageStartupMessages(library(utils))
# Create output dir ----
if(verbose) cat(task," Create output directory \n",sep="")
if(!dir.exists(folder_path))
dir.create(path = folder_path)
results_path <- paste0(folder_path,"/res")
if(!dir.exists(results_path))
dir.create(path = results_path)
img_path <- paste0(folder_path,"/img")
if(!dir.exists(img_path))
dir.create(path = img_path)
# Required functions ----
if(verbose) cat(task," Import functions \n",sep="")
source(script_functions)
source(choice_functions)
#### Data ----
if(verbose) cat(section," Database \n",sep="")
# Import data ----
if(verbose) cat(task," Import data \n",sep="")
if(verbose) cat(subtask,"Read from database \n")
data <- import_data(data_file, sheet)
control <- import_data(control_file, control_sheets)
# Pretreat ----
if(verbose) cat(task,"Pretreat \n")
if(verbose) cat(subtask,"Time \n")
time_max <- compute_time_max(data)
Time <- seq(0,time_max,length.out = simulated_data.time_number)
if(verbose) cat(subtask,"Survival curves \n")
data_pretreated <- pretreatment(data)
if(verbose) cat(subtask,"Survival curves (control group) \n")
control_pretreated <- pretreatment(control,data_pretreated,control_sheets)
# Transformation ----
if(verbose) cat(subtask,"Data transforming : survival differences \n")
data_transformed <- transformation(data_pretreated,control_pretreated)
#### Clustering ----
if(verbose) cat(section,"Clustering \n")
if(verbose) cat(task,"Compute clusters \n")
data_cluster <- do_clustering(data_transformed)
if(verbose) cat(task,"Compute clusters probabilities \n")
final_data <- Proba_cluster(data_cluster)
#### Post-process ----
if(verbose) cat(section,"Post-process \n")
# Graphical results ----
if(verbose) cat(task,"Export graphical results \n")
Export_images()
#### Clean up ----
if(verbose) cat(section,"Ending \n")
if(verbose) cat(task,"Save \n")
Path <- paste(results_path,"/Param_curves.RData",sep="")
save(data_pretreated, final_data, file = Path)
if(verbose) cat(task,"Clean up \n")
invisible(file.remove(Clustering_path))
invisible(file.remove(Proba_path))
rm(list=ls())
load("src/error_sd.RData")
ecart_type
head(ecart_type)
error_sd <-ecart_type
colnames(error_sd)
colnames(error_sd) <- c("n_nematode","sd")
save(error_sd,file = "src/error_sd.RData")
rm(error_sd)
rm(ecart_type)
load(error_sd_file)
load("src/error_sd.RData")
